import torch
from torch_geometric.nn.models import GAT, GCN
from torchvision.ops import MLP


class RankEdgeNet(torch.nn.Module):
    def __init__(
        self,
        num_x_features,
        embedding_size,
        num_layers_msg,
        num_layers_mlp,
        msg_passing="GCN",
        dropout=0,
        edge_embedding_operator="concat",
        **kwargs,
    ):
        super(RankEdgeNet, self).__init__()

        self.edge_embedding_operator = edge_embedding_operator
        if msg_passing == "GCN":
            self.msg_block = GCN(
                in_channels=num_x_features,
                hidden_channels=embedding_size,
                num_layers=num_layers_msg,
                dropout=dropout,
                **kwargs,
            )
        elif msg_passing == "GAT":
            self.msg_block = GAT(
                in_channels=num_x_features,
                hidden_channels=embedding_size,
                num_layers=num_layers_msg,
                dropout=dropout,
                **kwargs,
            )

        in_channels = 2 * embedding_size + 1 if self.edge_embedding_operator == "concat" else embedding_size + 1

        self.edge_mlp = MLP(
            in_channels=in_channels,
            hidden_channels=[embedding_size] * num_layers_mlp + [1],
            dropout=dropout,
        )

    def apply_edge_embedding(self, tail_embeddings, head_embeddings):
        if self.edge_embedding_operator == "concat":
            return torch.cat([tail_embeddings, head_embeddings], dim=1)
        elif self.edge_embedding_operator == "hadamard":
            return tail_embeddings*head_embeddings
        elif self.edge_embedding_operator == "mean":
            return (tail_embeddings + head_embeddings)/2
        return None

    def forward(self, x, edge_index, edge_weight):
        # Create node embeddings using the message block
        node_embeddings = self.msg_block(x, edge_index, edge_weight)
        # Create edge embeddings (by concatenating). An edge is node(tail) ---> node(head)
        tails, heads = edge_index
        edge_weight_reshaped = edge_weight.view(-1, 1)
        edge_embeddings = self.apply_edge_embedding(node_embeddings[tails], node_embeddings[heads])
        edge_embeddings = torch.cat([edge_embeddings, edge_weight_reshaped], dim=1) # add the weight of edge as an extra dimension
        # edge_embeddings = torch.cat([node_embeddings[tails], node_embeddings[heads], edge_weight_reshaped], dim=1)
        edge_logits = self.edge_mlp(edge_embeddings).squeeze(-1)
        return edge_logits
