from typing import Generator, Union
import itertools
import networkx as nx
import math
import random


def get_paths(G: nx.DiGraph, s: Union[int, str], t: Union[int, str]) -> Generator:
    """Get the paths of graph G from source s to terminal t."""

    def DFS(start, path=[], visited=set()):
        path.append(start)
        if start in visited:
            return
        else:
            visited.add(start)
        if start == t:
            yield path
            return
        for neighbor in G.neighbors(start):
            yield from DFS(neighbor, path=path.copy(), visited=visited.copy())

    return DFS(s)


def load_input_graph(file_path: str) -> nx.DiGraph:
    G = nx.DiGraph()
    with open(file_path, "r") as f:
        n_vertex, n_edges = map(int, f.readline().split())
        for line in f:
            line = line.split()
            u, v = line[:2]
            # weights
            time = float(line[2])
            logistic_cost = float(line[3]) if len(line) > 3 else None
            mode = line[4] if len(line) > 4 else None
            G.add_edge(u, v, time=time, logistic_cost=logistic_cost, mode=mode)

    if G.number_of_nodes() != n_vertex:
        raise ValueError(f"The graph contains {G.number_of_nodes()} and the file input says it has {n_vertex}")
    if G.number_of_edges() != n_edges:
        raise ValueError(f"The graph contains {G.number_of_edges()} and the file input says it has {n_edges}")

    return G


def generate_disruption_scenarios(edges: list, max_links_in_disruption: float, max_scenarios: int = 2_000_000):
    """
    Generate disruption scenarios by selecting combinations of edges.

    Args:
        edges: List of edges in the network
        max_links_in_disruption: Percentage of links to consider for disruption (0.0 to 1.0)
        max_scenarios: Maximum number of scenarios to generate

    Returns:
        Generator yielding disruption scenarios
    """
    R = max(1, int(len(edges) * max_links_in_disruption))

    # Calculate total number of combinations for all r values
    total_combinations = 0
    combinations_by_r = {}

    for r in range(1, R + 1):
        try:
            n_combinations = math.comb(len(edges), r)
            combinations_by_r[r] = n_combinations
            total_combinations += n_combinations
        except OverflowError:
            # For extremely large combinations
            combinations_by_r[r] = float("inf")
            total_combinations = float("inf")
            break

    # If total combinations don't exceed max_scenarios, generate all combinations
    if total_combinations <= max_scenarios:
        for r in range(1, R + 1):
            yield from itertools.combinations(edges, r)
        return

    # Always include all single-edge failures first
    yield from itertools.combinations(edges, 1)
    scenarios_generated = combinations_by_r.get(1, len(edges))

    # Distribute remaining scenarios across r = 2 to R
    if scenarios_generated >= max_scenarios:
        return

    remaining_scenarios = max_scenarios - scenarios_generated

    # Allocate remaining scenarios proportionally across r values
    for r in range(2, R + 1):
        if remaining_scenarios <= 0:
            break

        n_combinations = combinations_by_r.get(r, 0)

        if n_combinations <= remaining_scenarios:
            # If we can generate all combinations for this r, do so
            yield from itertools.combinations(edges, r)
            remaining_scenarios -= n_combinations
        else:
            # Otherwise, sample from the combinations
            if n_combinations > 10000:  # For very large combination spaces, use sampling
                edge_indices = list(range(len(edges)))
                sampled_indices_sets = set()  # To avoid duplicates

                while len(sampled_indices_sets) < remaining_scenarios:
                    sampled_indices = tuple(sorted(random.sample(edge_indices, r)))
                    if sampled_indices not in sampled_indices_sets:
                        sampled_indices_sets.add(sampled_indices)
                        yield tuple(edges[i] for i in sampled_indices)
            else:
                # For smaller spaces, generate combinations with a limit
                for i, combo in enumerate(itertools.combinations(edges, r)):
                    if i >= remaining_scenarios:
                        break
                    yield combo

            break  # We've used up all remaining scenarios

def get_total_disruption_scenarios(n_edges: int, max_links_in_disruption: float) -> int:
    """Get the total disruption scenarios based on number of edges and max_links_in_disruption disruptions"""
    R = int(n_edges * max_links_in_disruption)
    total = sum(math.comb(n_edges, r) for r in range(1, R + 1))
    return total
