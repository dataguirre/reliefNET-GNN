import torch
from torchmetrics.functional import kendall_rank_corrcoef

# def map_at_k(pred_edges: torch.Tensor, target_edges: torch.Tensor, index_edges: torch.Tensor, k_ratio=0.4):
#     graph_ids, count_edges = index_edges.unique(return_counts=True)
#     K = (k_ratio * count_edges).floor().int()
#     average_precisions = []
#     for graph_id, k in zip(graph_ids, K):
#         # find relevant edges of a graph
#         target_graph_edges = target_edges[index_edges == graph_id]
#         # I wont use the top k relevant edges because there may be ties, find the min score and set all edges with at least
#         # that score as relevant
#         min_score_at_k = torch.topk(target_graph_edges, k.item()).values.min()
#         relevant_graph_edges = torch.nonzero(target_graph_edges >= min_score_at_k, as_tuple=True)[0]
#         # find the ranking of edge predictions
#         pred_graph_edges = pred_edges[index_edges == graph_id]
#         rank_edge_predictions = torch.topk(pred_graph_edges, k.item()).indices
#         rank_edge_predictions = torch.isin(rank_edge_predictions, relevant_graph_edges).cumsum(dim=0)
#         positions = torch.arange(1, k.item() + 1, device=rank_edge_predictions.device)
#         average_precision = torch.div(rank_edge_predictions, positions).mean()
#         average_precisions.append(average_precision)
#     return torch.stack(average_precisions).mean()


def ndcg_at_k(pred_edges: torch.Tensor, target_edges: torch.Tensor, index_edges: torch.Tensor, k_ratio=0.4):
    graph_ids, count_edges = index_edges.unique(return_counts=True)
    K = (k_ratio * count_edges).floor().int()
    ndcgs = []
    for graph_id, k in zip(graph_ids, K):
        # find relevant edges of a graph
        target_graph_edges = target_edges[index_edges == graph_id]
        pred_graph_edges = pred_edges[index_edges == graph_id]
        ndcg = _ndcg_at_k(pred_graph_edges, target_graph_edges, k.item())
        ndcgs.append(ndcg)
    return torch.stack(ndcgs).mean()


def map_at_k(pred_edges: torch.Tensor, target_edges: torch.Tensor, index_edges: torch.Tensor, k_ratio=0.4):
    graph_ids, count_edges = index_edges.unique(return_counts=True)
    K = (k_ratio * count_edges).floor().int()
    average_precisions = []
    for graph_id, k in zip(graph_ids, K):
        # find relevant edges of a graph
        target_graph_edges = target_edges[index_edges == graph_id]
        pred_graph_edges = pred_edges[index_edges == graph_id]
        avg_precision = _average_precision_at_k(pred_graph_edges, target_graph_edges, k.item())
        average_precisions.append(avg_precision)
    return torch.stack(average_precisions).mean()


def kendall_tau_b_corrcoef(edge_logits: torch.Tensor, target_edges: torch.Tensor, graph_ids: torch.Tensor):
    kendall_corr_by_graph = []
    for graph_id in graph_ids.unique():
        target_edges_graph = target_edges[graph_ids == graph_id]
        edge_logits_graph = edge_logits[graph_ids == graph_id]
        graph_kendall_corr = kendall_rank_corrcoef(edge_logits_graph, target_edges_graph, variant="b")
        kendall_corr_by_graph.append(graph_kendall_corr)

    return torch.stack(kendall_corr_by_graph).mean()


def _average_precision_at_k(edge_logits: torch.Tensor, target_edges: torch.Tensor, k: int):
    """Calculate the average precision at k edges for a graph G"""
    # I wont use the top k relevant edges because there may be ties, find the min score and set all edges with at least
    # that score as relevant
    min_score_at_k = torch.topk(target_edges, k).values.min()
    relevant_edges = torch.nonzero(target_edges >= min_score_at_k, as_tuple=True)[0]
    # find the rank of predicted edges
    predicted_ranking = torch.topk(edge_logits, k).indices
    predicted_ranking_relevant = torch.isin(predicted_ranking, relevant_edges)
    positions = torch.arange(1, k + 1, device=predicted_ranking.device)
    average_precision = torch.div(predicted_ranking_relevant.cumsum(dim=0), positions)[predicted_ranking_relevant].mean()
    return average_precision


def _ndcg_at_k(edge_logits: torch.Tensor, target_edges: torch.Tensor, k: int):
    predicted_ranking = torch.topk(edge_logits, k).indices
    scores_predicted_ranking = target_edges[predicted_ranking]  # we use the real scores but the predicted ranking
    positions = torch.arange(1, k + 1, device=edge_logits.device)
    denominator = torch.log2(positions + 1)
    dcg = (scores_predicted_ranking / denominator).sum()

    # For the IDCG we use real ranking, not prredicted
    scores_real_ranking = torch.topk(target_edges, k).values
    idcg = (scores_real_ranking / denominator).sum()
    return dcg / idcg
